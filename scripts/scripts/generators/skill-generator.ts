#!/usr/bin/env bun

/**
 * Skill Markdown Generator
 *
 * Generates Claude Code skill files (.md) from extracted codebase knowledge:
 * - tech-stack.md - Framework versions and patterns
 * - code-patterns.md - Services, hooks, component patterns
 * - database-schema.md - Tables, enums, query patterns
 * - api-reference.md - API routes and methods
 */

import { mkdirSync, writeFileSync, existsSync } from 'fs';
import { join } from 'path';
import type { ExtractedKnowledge, TechStack, CodePatterns, DatabaseSchema, APIRoute } from '../extractors/base-extractor.ts';

/**
 * Generate all codebase knowledge skills
 */
export async function generateCodebaseSkills(knowledgeDir: string, knowledge: ExtractedKnowledge): Promise<void> {
  // Create knowledge directory
  if (!existsSync(knowledgeDir)) {
    mkdirSync(knowledgeDir, { recursive: true });
  }

  // Generate individual skill files
  await generateTechStackSkill(knowledgeDir, knowledge.techStack);
  await generateCodePatternsSkill(knowledgeDir, knowledge.codePatterns);

  if (knowledge.databaseSchema) {
    await generateDatabaseSchemaSkill(knowledgeDir, knowledge.databaseSchema);
  }

  if (knowledge.apiRoutes && knowledge.apiRoutes.length > 0) {
    await generateAPIReferenceSkill(knowledgeDir, knowledge.apiRoutes);
  }

  console.log(`[skill-generator] âœ… Generated codebase knowledge skills in ${knowledgeDir}`);
}

/**
 * Generate tech-stack.md skill
 */
async function generateTechStackSkill(knowledgeDir: string, techStack: TechStack): Promise<void> {
  const frameworks = techStack.frameworks.map(f => `- **${f.name}**: ${f.version}`).join('\n');
  const libraries = techStack.libraries.map(l => `- **${l.name}**: ${l.version}`).join('\n');
  const testing = techStack.testing?.map(t => `- **${t.framework}**: ${t.version}`).join('\n') || 'No testing frameworks detected';

  const content = `---
name: tech-stack
description: |
  ${techStack.language} project tech stack reference.
  USE WHEN needing framework versions, library imports, or tech stack patterns.
---

# Tech Stack Reference

This file contains the actual versions and patterns detected from the codebase.

## Language & Runtime
- **Language**: ${techStack.language}
- **Runtime**: ${techStack.runtime || 'Unknown'}

## Frameworks
${frameworks || 'No major frameworks detected'}

## Libraries
${libraries || 'No major libraries detected'}

${techStack.database ? `## Database
- **Type**: ${techStack.database.type}
- **ORM**: ${techStack.database.orm}
` : ''}

## Testing
${testing}

## Build Tools
${techStack.buildTools.map(t => `- ${t}`).join('\n') || 'No build tools detected'}

---

**Auto-generated by PAI Knowledge Extractor**
`;

  writeFileSync(join(knowledgeDir, 'tech-stack.md'), content);
}

/**
 * Generate code-patterns.md skill
 */
async function generateCodePatternsSkill(knowledgeDir: string, patterns: CodePatterns): Promise<void> {
  let servicesSection = '';
  if (patterns.services && patterns.services.length > 0) {
    servicesSection = `## Services

${patterns.services.map(service => `### ${service.name}
**File**: \`${service.filePath}\`

**Methods**:
${service.methods.map(m => `- \`${m.name}(${m.params.join(', ')})\`${m.returnType ? `: ${m.returnType}` : ''}`).join('\n')}
`).join('\n')}`;
  }

  let componentsSection = '';
  if (patterns.components && patterns.components.length > 0) {
    componentsSection = `## Components (Sample)

${patterns.components.slice(0, 20).map(comp => `### ${comp.name}
**File**: \`${comp.filePath}\`
**Type**: ${comp.isServerComponent ? 'Server Component' : 'Client Component'}
`).join('\n')}

*Showing first 20 of ${patterns.components.length} components*
`;
  }

  let hooksSection = '';
  if (patterns.hooks && patterns.hooks.length > 0) {
    hooksSection = `## Custom Hooks

${patterns.hooks.map(hook => `### ${hook.name}
**File**: \`${hook.filePath}\`
**Params**: ${hook.params.join(', ') || 'none'}
${hook.returnType ? `**Returns**: ${hook.returnType}` : ''}
`).join('\n')}`;
  }

  let modelsSection = '';
  if (patterns.models && patterns.models.length > 0) {
    modelsSection = `## Models

${patterns.models.map(model => `### ${model.name}
**File**: \`${model.filePath}\`
**Fields**: ${model.fields.length} fields
`).join('\n')}`;
  }

  const content = `---
name: code-patterns
description: |
  Codebase code patterns and structure.
  USE WHEN implementing features to follow existing patterns.
---

# Code Patterns

This file contains actual code patterns extracted from the codebase.

${servicesSection}

${componentsSection}

${hooksSection}

${modelsSection}

---

**Auto-generated by PAI Knowledge Extractor**
`;

  writeFileSync(join(knowledgeDir, 'code-patterns.md'), content);
}

/**
 * Generate database-schema.md skill
 */
async function generateDatabaseSchemaSkill(knowledgeDir: string, schema: DatabaseSchema): Promise<void> {
  let enumsSection = '';
  if (schema.enums && schema.enums.length > 0) {
    enumsSection = `## Enums

${schema.enums.map(e => `### ${e.name}
\`\`\`typescript
export const ${e.name} = pgEnum('${e.name}', [
  ${e.values.map(v => `'${v}'`).join(',\n  ')}
]);
\`\`\`
`).join('\n')}`;
  }

  let tablesSection = '';
  if (schema.tables && schema.tables.length > 0) {
    tablesSection = `## Tables

${schema.tables.map(t => `### ${t.name}
${t.fields.length > 0 ? `**Fields**: ${t.fields.length} fields detected` : '**Fields**: To be analyzed'}
`).join('\n')}

*Note: Full field details available in schema files*
`;
  }

  const content = `---
name: database-schema
description: |
  Database schema reference (${schema.orm}).
  USE WHEN working with database queries, migrations, or data models.
---

# Database Schema

This file contains database schemas extracted from the codebase.

**ORM**: ${schema.orm}

${enumsSection}

${tablesSection}

---

**Auto-generated by PAI Knowledge Extractor**
`;

  writeFileSync(join(knowledgeDir, 'database-schema.md'), content);
}

/**
 * Generate api-reference.md skill
 */
async function generateAPIReferenceSkill(knowledgeDir: string, routes: APIRoute[]): Promise<void> {
  const groupedRoutes: Record<string, APIRoute[]> = {};

  // Group routes by base path
  for (const route of routes) {
    const basePath = route.path.split('/').slice(0, 3).join('/'); // /api/resource
    if (!groupedRoutes[basePath]) groupedRoutes[basePath] = [];
    groupedRoutes[basePath].push(route);
  }

  const routesSection = Object.entries(groupedRoutes)
    .map(([basePath, routeList]) => {
      const routeLines = routeList.map(r =>
        `- **${r.method}** \`${r.path}\` ${r.auth ? 'ðŸ”’' : ''}
  - File: \`${r.filePath}\``
      ).join('\n');

      return `### ${basePath}

${routeLines}`;
    })
    .join('\n\n');

  const content = `---
name: api-reference
description: |
  API routes reference.
  USE WHEN implementing or calling API endpoints.
---

# API Reference

This file contains all API routes extracted from the codebase.

**Total Routes**: ${routes.length}

${routesSection}

---

**Legend**:
- ðŸ”’ = Requires authentication

**Auto-generated by PAI Knowledge Extractor**
`;

  writeFileSync(join(knowledgeDir, 'api-reference.md'), content);
}
